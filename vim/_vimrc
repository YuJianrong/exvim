" ======================================================================================
" File         : _vimrc
" Author       : Wu Jie 
" Last Change  : 10/19/2008 | 15:33:27 PM | Sunday,October
" Description  : 
" ======================================================================================

"/////////////////////////////////////////////////////////////////////////////
" General
"/////////////////////////////////////////////////////////////////////////////

" put your own user name here
let g:ex_usr_name = "Wu Jie"

set nocompatible " Use Vim settings, rather then Vi settings (much better!). This must be first, because it changes other options as a side effect.
set langmenu=none " always use English menu

au FileType c,cpp set nomodeline " this will avoid bug in my project with namespace ex, the vim will tree ex:: as modeline.

" source $VIMRUNTIME/vimrc_example.vim
behave xterm  " set mouse behavior as xterm

"set path=.,/usr/include/*,, " where gf, ^Wf, :find will search 
set backup " make backup file and leave it around 
"set backupdir=%tmp%
"set directory=.,%tmp%
set backupdir=$VIM/data/backup " where to put backup file 
set directory=$VIM/data/swap " where to put swap file 

" programming related 
set tags+=./tags,./../tags,./**/tags,tags " which tags files CTRL-] will find 
set makeef=error.err " the errorfile for :make and :grep 

set viminfo+=! " make sure it can save viminfo 
filetype on " enable file type detection 
filetype plugin on " enable loading the plugin for appropriate file type 

" Redefine the shell redirection operator to receive both the stderr messages
" and stdout messages
set shellredir=>%s\ 2>&1

set history=50 " keep 50 lines of command line history
set updatetime=1000 " default = 4000
set autoread " auto read same-file change ( better for vc/vim change )

" XXX
"set isk+=$,%,#,- " none of these should be word dividers 

" FIXME: no fix yet in vim72
" there have a bug with visual copy, shows the there is nothing in register *
" set clipboard=unnamed " use clipboard register '*'(unnamed) for all y, d, c, p ops, use autoselect to avoid selection p bugs.

" enlarge maxmempattern from 1000 to ... (2000000 will give it without limit)
set maxmempattern=1000

" set quick fix error format
" default errorformat = %f(%l) : %t%*\D%n: %m,%*[^"]"%f"%*\D%l: %m,%f(%l) : %m,%*[^ ] %f %l: %m,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,%f|%l| %m
"set errorformat+=%D%\\d%\\+\>------\ %.%#Project:\ %f%\\,%.%# " msvc 2005 error-entering
"set errorformat+=%D%\\d%\\+\>------\ %.%#Project:\ %f%\\,%.%# " msvc 2005 error-entering
"set errorformat+=%X%\\d%\\+\>%.%#%\\d%\\+\ error(s)%.%#%\\d%\\+\ warning(s) " msvc 2005 error-leaving
"set errorformat+=%\\d%\\+\>%f(%l)\ :\ %t%*\\D%n:\ %m " msvc 2005 error-format
"set errorformat+=%f(%l\\,%c):\ %m " fxc shader error-format


"/////////////////////////////////////////////////////////////////////////////
" Variable settings ( set all )
"/////////////////////////////////////////////////////////////////////////////

" ------------------------------------------------------------------ 
" Desc: Visual
" ------------------------------------------------------------------ 

set showmatch " show matching paren 
set matchtime=0 " 0 second to show the matching paren ( much faster )
set nu " Show LineNumber
set scrolloff=0 " minimal number of screen lines to keep above and below the cursor 
set nowrap " I don't like wrap, cause in split window mode, it feel strange

"set default guifont
if has("gui_running")
    if has("gui_gtk2")
        set guifont=Luxi\ Mono\ 10
    elseif has("x11")
        " Also for GTK 1
        set guifont=*-lucidatypewriter-medium-r-normal-*-*-180-*-*-m-*-*
    elseif has("gui_win32")
        set guifont=Lucida_Console:h9
    endif
endif

" color scheme define
if has("gui_running")
    silent exec "colorscheme ex"
else " if we are in terminal mode
    silent exec "colorscheme darkblue"
endif
au ColorScheme * call UpdateHighlights()

" update highlights
let s:ex_HighlightsInited = 0 
function UpdateHighlights()

    let s:ex_HighlightsInited = 1 

    " ======================================================== 
    " exUtility
    " ======================================================== 

    hi ex_SynHL1 gui=none guibg=LightCyan term=none cterm=none ctermbg=LightCyan
    hi ex_SynHL2 gui=none guibg=LightMagenta term=none cterm=none ctermbg=LightMagenta
    hi ex_SynHL3 gui=none guibg=LightRed term=none cterm=none ctermbg=LightRed
    hi ex_SynHL4 gui=none guibg=LightGreen term=none cterm=none ctermbg=LightGreen

    hi ex_SynSelectLine gui=none guibg=#bfffff term=none cterm=none ctermbg=LightCyan
    hi ex_SynConfirmLine gui=none guibg=#ffe4b3 term=none cterm=none ctermbg=DarkYellow
    hi ex_SynObjectLine gui=none guibg=#ffe4b3 term=none cterm=none ctermbg=DarkYellow

    hi link ex_SynError Error
    hi link ex_SynFold Comment
    hi link ex_SynFileName Statement
    hi link ex_SynLineNr LineNr
    hi link ex_SynNormal Normal

    hi ex_SynTransparent gui=none guifg=background term=none cterm=none ctermfg=DarkGray
    hi ex_SynSearchPattern gui=bold guifg=DarkRed guibg=LightGray term=bold cterm=bold ctermfg=DarkRed ctermbg=LightGray
    hi ex_SynTitle term=bold cterm=bold ctermfg=DarkYellow gui=bold guifg=Brown

    hi ex_SynJumpMethodS term=none cterm=none ctermfg=Red gui=none guifg=Red 
    hi ex_SynJumpMethodG term=none cterm=none ctermfg=Blue gui=none guifg=Blue 
    hi link ex_SynJumpSymbol Comment

    hi exCommentLable term=standout ctermfg=DarkYellow ctermbg=Red gui=none guifg=LightYellow guibg=Red
    " hi exCommentLable term=standout ctermfg=DarkYellow ctermbg=Red gui=none guifg=DarkRed guibg=LightMagenta

    " ======================================================== 
    " exMacroHighlight
    " ======================================================== 

    hi exMacroDisable term=none cterm=none ctermfg=DarkGray gui=none guifg=DarkGray
    hi link cCppOut exMacroDisable                
    hi exMH_GroupNameEnable term=bold cterm=bold ctermfg=DarkRed ctermbg=LightGray gui=bold guifg=DarkRed guibg=LightGray
    hi exMH_GroupNameDisable term=bold cterm=bold ctermfg=Red ctermbg=DarkGray gui=bold guifg=DarkGray guibg=LightGray
    hi link exMH_MacroEnable cPreProc
    hi link exMH_MacroDisable exMacroDisable

    " ======================================================== 
    " exProject
    " ======================================================== 

    hi exPJ_TreeLine gui=none guifg=DarkGray term=none cterm=none ctermfg=Gray
    hi exPJ_SynDir gui=bold guifg=Brown term=bold cterm=bold ctermfg=DarkRed
    hi exPJ_SynFile gui=none guifg=Magenta term=none cterm=none ctermfg=Magenta

    hi exPJ_SynSrcFile gui=none guifg=Blue term=none cterm=none ctermfg=Blue
    hi exPJ_SynHeaderFile gui=none guifg=DarkGreen term=none cterm=none ctermfg=DarkGreen
    hi exPJ_SynErrorFile gui=none guifg=Red term=none cterm=none ctermfg=Red

    " ======================================================== 
    " exCScope
    " ======================================================== 

    hi exCS_SynQfNumber gui=none guifg=Red term=none cterm=none ctermfg=Red

    " ======================================================== 
    " ShowMarks
    " ======================================================== 

    " For marks a-z
    hi ShowMarksHLl term=none cterm=none ctermbg=LightBlue gui=none guibg=LightBlue
    " For marks A-Z
    hi ShowMarksHLu term=bold cterm=bold ctermbg=LightRed ctermfg=DarkRed gui=bold guibg=LightRed guifg=DarkRed
    " For all other marks
    hi ShowMarksHLo term=bold cterm=bold ctermbg=LightYellow ctermfg=DarkYellow gui=bold guibg=LightYellow guifg=DarkYellow
    " For multiple marks on the same line.
    hi ShowMarksHLm term=bold cterm=bold ctermbg=LightGreen ctermfg=DarkGreen gui=bold guibg=LightGreen guifg=DarkGreen

    " ======================================================== 
    " MiniBufExplorer
    " ======================================================== 

    " for buffers that have NOT CHANGED and are NOT VISIBLE.
    hi MBENormal ctermbg=LightGray ctermfg=DarkGray guibg=LightGray guifg=DarkGray
    " for buffers that HAVE CHANGED and are NOT VISIBLE
    hi MBEChanged ctermbg=Red ctermfg=DarkRed guibg=Red guifg=DarkRed
    " buffers that have NOT CHANGED and are VISIBLE
    hi MBEVisibleNormal term=bold cterm=bold ctermbg=Gray ctermfg=Black gui=bold guibg=Gray guifg=Black
    " buffers that have CHANGED and are VISIBLE
    hi MBEVisibleChanged term=bold cterm=bold ctermbg=DarkRed ctermfg=Black gui=bold guibg=DarkRed guifg=Black

    " ======================================================== 
    " TagList
    " ======================================================== 

    " TagListTagName  - Used for tag names
    hi MyTagListTagName term=bold cterm=none ctermfg=Black ctermbg=DarkYellow gui=none guifg=Black guibg=#ffe4b3
    " TagListTagScope - Used for tag scope
    hi MyTagListTagScope term=NONE cterm=NONE ctermfg=Blue gui=NONE guifg=Blue 
    " TagListTitle    - Used for tag titles
    hi MyTagListTitle term=bold cterm=bold ctermfg=DarkRed ctermbg=LightGray gui=bold guifg=DarkRed guibg=LightGray 
    " TagListComment  - Used for comments
    hi MyTagListComment ctermfg=DarkGreen guifg=DarkGreen 
    " TagListFileName - Used for filenames
    hi MyTagListFileName term=bold cterm=bold ctermfg=Black ctermbg=LightBlue gui=bold guifg=Black guibg=LightBlue
endfunction

" if you don't use color scheme, you may properly not run the code above, so
" run it manually here
if s:ex_HighlightsInited == 0
    call UpdateHighlights()
endif

" ------------------------------------------------------------------ 
" Desc: Vim UI
" ------------------------------------------------------------------ 

set wildmenu " turn on wild menu, try typing :h and press <Tab> 
set showcmd	" display incomplete commands
set cmdheight=1 " 1 screen lines to use for the command-line 
set ruler " show the cursor position all the time
set hid " allow to change buffer without saving 
set shortmess=atI " shortens messages to avoid 'press a key' prompt 
set lazyredraw " do not redraw while executing macros (much faster) 
set display+=lastline " for easy browse last line with wrap text

" Set window's width to 130 columns and height to 40 rows
" (if it's GUI)
if has("gui_running")
    set lines=40 columns=130
endif

set showfulltag " show tag with function protype.
set guioptions+=b " Present the bottom scrollbar when the longest visible line exceen the window

" disable menu & toolbar
set guioptions-=m
set guioptions-=T

"set encoding=japan
"set termencoding=cp932

"set encoding=cp932
"set termencoding=cp932

"set grepprg=grep\ -n

" ------------------------------------------------------------------ 
" Desc: Text edit
" ------------------------------------------------------------------ 

set ai " autoindent 
set si " smartindent 
set backspace=indent,eol,start " allow backspacing over everything in insert mode
" indent options
"  see help cinoptions-values for more details
set	cinoptions=>s,e0,n0,f0,{0,}0,^0,:0,=s,l0,b0,g0,hs,ps,ts,is,+s,c3,C0,0,(0,us,U0,w0,W0,m0,j0,)20,*30
" default '0{,0},0),:,0#,!^F,o,O,e' disable 0# for not ident preprocess
" set cinkeys=0{,0},0),:,!^F,o,O,e

" Official diff settings
set diffexpr=MyDiff()
function MyDiff()
  let opt = '-a --binary -w '
  if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
  if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
  let arg1 = v:fname_in
  if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
  let arg2 = v:fname_new
  if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
  let arg3 = v:fname_out
  if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
  silent execute '!' .  'diff ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3
endfunction

set cindent shiftwidth=4 " Set cindent on to autoinent when editing C/C++ file, with 4 shift width
set tabstop=4 " Set tabstop to 4 characters
set expandtab " Set expandtab on, the tab will be change to space automaticaly
au BufEnter *.py,*.pyw call CheckIfExpandTab() " if edit python scripts, check if have \t. ( python said: the programme can only use \t or not, but can use them together )
function CheckIfExpandTab()
    let has_noexpandtab = search('^\t','wn')
    let has_expandtab = search('^    ','wn')

    "
    if has_noexpandtab && has_expandtab
        let idx = inputlist ( ["ERROR: current file exists both expand and noexpand TAB, python can only use one of these two mode in one file.\nSelect Tab Expand Type:",
                              \ '1. expand (tab=space, recommended)', 
                              \ '2. noexpand (tab=\t, currently have risk)',
                              \ '3. do nothing (I will handle it by myself)'])
        let tab_space = printf('%*s',&tabstop,'')
        if idx == 1
            let has_noexpandtab = 0
            let has_expandtab = 1
            silent exec '%s/\t/' . tab_space . '/g'
        elseif idx == 2
            let has_noexpandtab = 1
            let has_expandtab = 0
            silent exec '%s/' . tab_space . '/\t/g'
        else
            return
        endif
    endif

    " 
    if has_noexpandtab == 1 && has_expandtab == 0  
        echomsg 'substitute space to TAB...'
        set noexpandtab
        echomsg 'done!'
    elseif has_noexpandtab == 0 && has_expandtab == 1
        echomsg 'substitute TAB to space...'
        set expandtab
        echomsg 'done!'
    else
        " it may be a new file
        " we use original vim setting
    endif
endfunction

" Set Number format to null(default is octal) , when press CTRL-A on number
" like 007, it would not become 010
set nf=
" In Visual Block Mode, cursor can be positioned where there is no actual character
set ve=block

" ------------------------------------------------------------------ 
" Desc: Fold text
" ------------------------------------------------------------------ 

set foldmethod=marker foldmarker={,} foldlevel=9999
set diffopt=filler,context:9999

" ------------------------------------------------------------------ 
" Desc: Search
" ------------------------------------------------------------------ 

" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
if &t_Co > 2 || has("gui_running")
    syntax on
    set hlsearch
endif
set incsearch " do incremental searching
set ignorecase " Set search/replace pattern to ignore case 
set smartcase " Set smartcase mode on, If there is upper case character in the search patern, the 'ignorecase' option will be override.

" set this to use id-utils for global search
set grepprg=lid\ -Rgrep\ -s
set grepformat=%f:%l:%m

" ------------------------------------------------------------------ 
" Desc: Syntax
" ------------------------------------------------------------------ 

let c_gnu = 1
let c_no_curly_error = 1
"let c_no_bracket_error = 1

"/////////////////////////////////////////////////////////////////////////////
" Key Mappings
"/////////////////////////////////////////////////////////////////////////////

" Don't use Ex mode, use Q for formatting
map Q gq  

" XXX: currently it is no-use
" Set new Rgrep as the grep to search patterns on the C/C++ files as default
"command -nargs=+ Rgrep :grep -r --include="*.cpp" --include="*.c" --include="*.hpp" --include="*.h" <q-args> *
"map <Leader>fc :call <SID>Grep_Cfiles()<CR>
"function s:Grep_Cfiles()
"    let l_str=input("Input the keyword to be searched: ")
"    exec ":grep -r --include=\"*.cpp\" --include=\"*.c\" --include=\"*.hpp\" --include=\"*.h\" " . l_str . " *"
"endfunction

" define the copy/paste judged by clipboard
if &clipboard ==# "unnamed"
    " fix the visual paste bug in vim
    " vnoremap <silent>p :call g:()<CR>
else
    " general copy/paste.
    map <unique> <leader>y "*y
    map <unique> <leader>p "*p
    map <unique> <leader>P "*P
endif

" F12: Insert '#if 0' and '#endif' between the selection
vmap <unique> <F12> :call g:ex_InsertIFZero()<CR>
nmap <unique> <F12> :call g:ex_RemoveIFZero()<CR>

" XXX: F10 looks like have some feature, when map with F10, the gv will take no effects
" F9:  Insert/Remove macro extend ("\") after all the lines of the selection
vmap <unique> <F9> :call g:ex_InsertRemoveExtend()<CR>

" F8:  Set Search pattern highlight on/off
nmap <unique> <F8> :let @/=""<CR>

" A-F1:  Switch to English Mode (Both Enconding and uiFont)
nmap <unique> <A-F1> :set guifont=Lucida_Console:h9<CR>:set encoding=latin1<CR>
" A-F2:  Switch to Chinese Mode (Both Enconding and uiFont)
nmap <unique> <A-F2> :set guifont=NSimSun:cGB2312:h9<CR>:set encoding=cp936<CR>
" A-F3:  Switch to Japanese Mode 
nmap <unique> <A-F3> :set guifont=MS_Gothic:cSHIFTJIS:h9<CR>:set encoding=cp932<CR>

" map Ctrl-Tab to switch window
nmap <unique> <S-Up> <C-W><Up>
nmap <unique> <S-Down> <C-W><Down>
nmap <unique> <S-Left> <C-W><Left>
nmap <unique> <S-Right> <C-W><Right>
nmap <unique> <silent><Leader><Tab> :call g:ex_SwitchBuffer()<CR>

" for the exUtility Plugin
nmap <unique> <silent><Leader><ESC> :call g:ex_SwitchBuffer()<CR><ESC>

" change the original file jump method to this one
nnoremap <unique> gf :call g:ex_QuickFileJump()<CR>

" VimTip #401: A mapping for easy switching between buffers
" NOTE: there has a bug, in window (not fullscree) mode, some times the buffer 
"       will jump to other display screen ( if you use double screen ).      
" nmap <silent> <C-Right> :bn!<CR>
" nmap <silent> <C-Left> :bp!<CR>
nmap <unique> <silent> <C-Right> :call g:ex_GotoBuffer('next')<CR>
nmap <unique> <silent> <C-Left> :call g:ex_GotoBuffer('prev')<CR>
nmap <unique> <silent> <C-Tab> :call g:ex_SwapToLastEditBuffer()<CR>

" Move in fold
map <unique> z<Up> zk
map <unique> z<Down> zj
map <unique> <A-Up> zk
map <unique> <A-Down> zj

" Easy Diff goto
map <unique> <C-Up> [c
map <unique> <C-Down> ]c

" VimTip #412: Easy menu-style switch between files with a simple map
" map <C-b> :buffers<CR>:e #

" Like J, I make a de-joint for command mode
" nmap <C-j> a<CR><ESC>

" Enhance '<' '>' , do not need to reselect the block after shift it.
vnoremap <unique> < <gv
vnoremap <unique> > >gv

" Fold close & Fold open
map <unique> <kPlus> zo
map <unique> <kMinus> zc

" map g:ex_Kwbd(1) to \bd will close buffer and keep window
nmap <unique> <Leader>bd :call g:ex_Kwbd(1)<CR>
nmap <unique> <C-F4> :call g:ex_Kwbd(1)<CR>

" map Up & Down to gj & gk, helpful for wrap text edit
map <unique> <Up> gk
map <unique> <Down> gj

" map for completion see :help ins-completion for whole completions
" search tags 
inoremap <unique> <c-j> <C-X><C-]>
" search in current files, preview first. remove the original c-p
inoremap <unique> <c-p> <C-X><C-P>

" map for quick add special comments
map <unique> <leader>ws :SEG<CR>
map <unique> <leader>wd :DEF<CR>
map <unique> <leader>we :SEP<CR>
map <unique> <leader>wc :DEC<CR>
map <unique> <leader>wh :HEADER<CR>

" VimTip 329: A map for swapping words
" http://vim.sourceforge.net/tip_view.php?tip_id=
" Then when you put the cursor on or in a word, press "\sw", and
" the word will be swapped with the next word.  The words may
" even be separated by punctuation (such as "abc = def").
nmap <unique> <silent><leader>sw "_yiw:s/\(\%#\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/<cr><c-o>

"/////////////////////////////////////////////////////////////////////////////
" Command
"/////////////////////////////////////////////////////////////////////////////

" TODO
" perforce key mapping
"let g:proj_run1='!p4 edit %f'
"nmap <Leader>po :silent !p4 edit %<CR>
"nmap <Leader>pr :silent !p4 revert %<CR>
command Checkout :silent !p4 edit %
command Revert :silent !p4 revert %
command Changelist :silent !p4 change
command ShowChangelist :!p4 changes -s pending -u jwu

"/////////////////////////////////////////////////////////////////////////////
" Auto Command
"/////////////////////////////////////////////////////////////////////////////

" ------------------------------------------------------------------ 
" Desc: Only do this part when compiled with support for autocommands.
" ------------------------------------------------------------------ 

if has("autocmd")
  " Enable file type detection.
  " Use the default filetype settings, so that mail gets 'tw' set to 72,
  " 'cindent' is on in C files, etc.
  " Also load indent files, to automatically do language-dependent indenting.
  filetype plugin indent on

  " Put these in an autocmd group, so that we can delete them easily.
  augroup vimrcEx
  au!

  " For all text files set 'textwidth' to 78 characters.
  autocmd FileType text setlocal textwidth=78

  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

  augroup END
endif " has("autocmd")

" ------------------------------------------------------------------ 
" Desc: Buffer
" ------------------------------------------------------------------ 

au BufNewFile,BufEnter * set cpoptions+=d " NOTE: ctags find the tags file from the current path instead of the path of currect file
au BufEnter * :syntax sync fromstart " ensure every file does syntax highlighting (full) 
au BufNewFile,BufRead *.avs set syntax=avs " for avs syntax file.
au BufWritePost * call g:ex_UpdateCurrentBuffer() 

" FIXME: may have some problems with exUtility
" Change current directory to the file of the buffer ( from Script#65"CD.vim"
" au   BufEnter *   execute ":lcd " . expand("%:p:h") 

" ------------------------------------------------------------------ 
" Desc: 
" ------------------------------------------------------------------ 

if has("gui_running")
    if has("win32")
        au GUIEnter * simalt ~x " Maximize window when enter vim
    elseif has("unix")
        " TODO: no way right now
    endif
endif

" ------------------------------------------------------------------ 
" Desc: Disable auto-comment for c/cpp and vim-script
" ------------------------------------------------------------------ 

au FileType c,cpp set comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,f:// 
au FileType vim set comments=sO:\"\ -,mO:\"\ \ ,eO:\"\",f:\"

"/////////////////////////////////////////////////////////////////////////////
" Plugin Configurations
"/////////////////////////////////////////////////////////////////////////////

" ------------------------------------------------------------------ 
" Desc: ShowMarks
" ------------------------------------------------------------------ 

let g:showmarks_enable = 1
let showmarks_include = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
" Ignore help, quickfix, non-modifiable buffers
let showmarks_ignore_type = "hqm"
" Hilight lower & upper marks
let showmarks_hlline_lower = 1
let showmarks_hlline_upper = 0 

" quick remove mark
" nmap <F9> \mh

" ------------------------------------------------------------------ 
" Desc: exUtility
" ------------------------------------------------------------------ 

" quick highlight 
nmap <unique> <silent> <a-1> :call g:ex_Highlight_Normal(1)<CR>
nmap <unique> <silent> <a-2> :call g:ex_Highlight_Normal(2)<CR>
nmap <unique> <silent> <a-3> :call g:ex_Highlight_Normal(3)<CR>
nmap <unique> <silent> <a-4> :call g:ex_Highlight_Normal(4)<CR>

vmap <unique> <silent> <a-1> :call g:ex_Highlight_Visual(1)<CR>
vmap <unique> <silent> <a-2> :call g:ex_Highlight_Visual(2)<CR>
vmap <unique> <silent> <a-3> :call g:ex_Highlight_Visual(3)<CR>
vmap <unique> <silent> <a-4> :call g:ex_Highlight_Visual(4)<CR>

command -narg=? -complete=customlist,g:ex_CompleteBySymbolFile HL1 call g:ex_Highlight_Text(1, "<args>")
command -narg=? -complete=customlist,g:ex_CompleteBySymbolFile HL2 call g:ex_Highlight_Text(2, "<args>")
command -narg=? -complete=customlist,g:ex_CompleteBySymbolFile HL3 call g:ex_Highlight_Text(3, "<args>")
command -narg=? -complete=customlist,g:ex_CompleteBySymbolFile HL4 call g:ex_Highlight_Text(4, "<args>")

map <unique> <silent> <a-0> :call g:ex_HighlightCancle(0)<CR>
map <unique> <silent> <Leader>0 :call g:ex_HighlightCancle(0)<CR>
map <unique> <silent> <Leader>1 :call g:ex_HighlightCancle(1)<CR>
map <unique> <silent> <Leader>2 :call g:ex_HighlightCancle(2)<CR>
map <unique> <silent> <Leader>3 :call g:ex_HighlightCancle(3)<CR>
map <unique> <silent> <Leader>4 :call g:ex_HighlightCancle(4)<CR>

" copy only full path name
nmap <unique> <silent> <leader>y1 :call g:ex_Yank( fnamemodify(bufname('%'),":p:h") )<CR>
" copy only file name
nmap <unique> <silent> <leader>y2 :call g:ex_Yank( fnamemodify(bufname('%'),":p:t") )<CR>
" copy full path + filename
nmap <unique> <silent> <leader>y3 :call g:ex_Yank( fnamemodify(bufname('%'),":p") )<CR>
" copy path + filename for code
nmap <unique> <silent> <leader>yb :call g:ex_YankBufferNameForCode()<CR>
" copy path for code
nmap <unique> <silent> <leader>yp :call g:ex_YankFilePathForCode()<CR>

" VimTip 311: Open the folder containing the currently open file
" http://vim.sourceforge.net/tip_view.php?tip_id=
" 
" Occasionally, on windows, I have files open in gvim, that the folder for 
" that file is not open. This key map opens the folder that contains the 
" currently open file. The expand() is so that we don't try to open the 
" folder of an anonymous buffer, we would get an explorer error dialog in 
" that case.
" 
if has("gui_running")
    if has("win32")
        " Open the folder containing the currently open file. Double <CR> at end
        " is so you don't have to hit return after command. Double quotes are
        " not necessary in the 'explorer.exe %:p:h' section.
        " :map <silent> <C-F5> :if expand("%:p:h") != ""<CR>:!start explorer.exe %:p:h<CR>:endif<CR><CR>

        " explore the vimfile directory
        :map <unique> <silent> <C-F5> :call g:ex_Yank(getcwd() . "\\_vimfiles")<CR>
        :map <unique> <silent> <A-F5> :call g:ex_Explore(getcwd() . "\\_vimfiles")<CR>
        " explore the cwd directory
        :map <unique> <silent> <C-F6> :call g:ex_Yank(getcwd())<CR>
        :map <unique> <silent> <A-F6> :call g:ex_Explore(getcwd())<CR>
        " explore the diretory current file in
        :map <unique> <silent> <C-F7> :call g:ex_Yank(expand("%:p:h"))<CR>
        :map <unique> <silent> <A-F7> :call g:ex_Explore(expand("%:p:h"))<CR>
    endif
endif
" 
" Tom.

" project gen/copy/build
command -narg=? -complete=customlist,g:ex_CompleteGMakeArgs GMake call g:ex_GCCMake("<args>")
command -narg=? -complete=customlist,g:ex_CompleteGMakeArgs SMake call g:ex_ShaderMake("<args>")
command -narg=* -complete=customlist,g:ex_CompleteVMakeArgs VMake call g:ex_VCMake("<args>")
command -narg=* VBat call g:ex_VCMakeBAT(<f-args>)
command -narg=? -complete=customlist,g:ex_CompleteUpdateArgs Update call g:ex_UpdateVimFiles("<args>")
command -narg=? -complete=customlist,g:ex_CompleteQCopyArgs QCopy call g:ex_CopyQuickGenProject("<args>")

" inherits genreate
command -narg=1 -complete=customlist,g:ex_CompleteBySymbolFile GV call g:ex_GenInheritsDot('<args>',"all")
command -narg=1 -complete=customlist,g:ex_CompleteBySymbolFile GVP call g:ex_GenInheritsDot('<args>',"parent")
command -narg=1 -complete=customlist,g:ex_CompleteBySymbolFile GVC call g:ex_GenInheritsDot('<args>',"children")
map <unique> <silent> <Leader>gv :call g:ex_ViewInheritsImage()<CR>

" code writing
command LINE call g:ex_PutLine(86, '-')
command -narg=1 NSS call g:ex_PutNamespaceStart("<args>")
command -narg=1 NSE call g:ex_PutNamespaceEnd("<args>")
command -narg=1 NS call g:ex_PutNamespace("<args>")
command HEADER call g:ex_PutHeader()
command SEP call g:ex_PutSeparate()
command SEG call g:ex_PutSegment()
command NOTE call g:ex_PutNote()
command DEF call g:ex_PutDefine()
command DEC call g:ex_PutDeclaration()
command DES call g:ex_PutDescription()
command MAIN call g:ex_PutMain()
command -narg=1 CLASS call g:ex_PutClass( "class", "<args>" )
command -narg=1 STRUCT call g:ex_PutClass( "struct", "<args>" )

" src-highlight
command -range=% SHL call g:ex_SrcHighlight( <line1>, <line2> )

" mark (special) text
let g:ex_todo_keyword = 'NOTE REF EXAMPLE SAMPLE CHECK'
let g:ex_comment_lable_keyword = 'DELME TEMP MODIFY ADD KEEPME ' " for editing
let g:ex_comment_lable_keyword .= 'DEBUG CRASH DUMMY UNUSED TESTME ' " for testing 
let g:ex_comment_lable_keyword .= 'HACK OPTME HARDCODE REFACTORING DUPLICATE REDUNDANCY ' " for refactoring

vnoremap <unique> <Leader>mk :MK 
nnoremap <unique> <Leader>mk :call g:ex_RemoveSpecialMarkText() <CR>
command -range -narg=1 -complete=customlist,g:ex_CompleteMKArgs MK call g:ex_MarkText("<args>", <line1>, <line2> )

" add plugin we use to prevent them record as edit-buffer
let g:exUT_plugin_list = ["-MiniBufExplorer-","__Tag_List__"] 

" ------------------------------------------------------------------ 
" Desc: exTagSelect
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <Leader>ts :ExtsSelectToggle<CR>
nnoremap <unique> <silent> <Leader>tt :ExtsStackToggle<CR>
nnoremap <unique> <silent> <Leader>tg :ExtsGoDirectly<CR>

map <unique> <silent> <Leader>] :ExtsGoDirectly<CR>
map <unique> <silent> <Leader>tb :BackwardTagStack<CR>
map <unique> <silent> <Leader>tf :ForwardTagStack<CR>

let g:exTS_backto_editbuf = 0
let g:exTS_close_when_selected = 1
let g:exTS_stack_close_when_selected = 0
let g:exTS_window_direction = 'bel'

" ------------------------------------------------------------------ 
" Desc: exGlobalSearch
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <Leader>gs :ExgsSelectToggle<CR>
nnoremap <unique> <silent> <Leader>gq :ExgsQuickViewToggle<CR>
nnoremap <unique> <silent> <Leader>gt :ExgsStackToggle<CR>
nnoremap <unique> <silent> <Leader>gg :ExgsGoDirectly<CR>
nnoremap <unique> <silent> <Leader>n :ExgsGotoNextResult<CR>
nnoremap <unique> <silent> <Leader>N :ExgsGotoPrevResult<CR>

map <unique> <silent> <Leader>gb :BackwardSearchStack<CR>
map <unique> <silent> <Leader>gf :ForwardSearchStack<CR>
map <unique> <S-f> :GS 

let g:exGS_backto_editbuf = 0
let g:exGS_close_when_selected = 0
let g:exGS_stack_close_when_selected = 0
let g:exGS_window_direction = 'bel'

" ------------------------------------------------------------------ 
" Desc: exSymbolTable
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <Leader>ss :ExslSelectToggle<CR>
nnoremap <unique> <silent> <Leader>sq :ExslQuickViewToggle<CR>
nnoremap <unique> <silent> <Leader>sg :ExslGoDirectly<CR>
" NOTE: the / can be mapped to other script ( for example exSearchComplete ), so here use nmap instead of nnoremap 
nmap <unique> <A-S-l> :ExslQuickSearch<CR>/ 

let g:exSL_SymbolSelectCmd = 'TS'

" ------------------------------------------------------------------ 
" Desc: exCscope
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <F2> :CSIC<CR>
nnoremap <unique> <silent> <Leader>ci :CSID<CR>
nnoremap <unique> <silent> <F3> :ExcsParseFunction<CR>
nnoremap <unique> <silent> <Leader>cd :CSDD<CR>
nnoremap <unique> <silent> <Leader>cc :CSCD<CR>
nnoremap <unique> <silent> <Leader>cs :ExcsSelectToggle<CR>
nnoremap <unique> <silent> <Leader>cq :ExcsQuickViewToggle<CR>

let g:exCS_backto_editbuf = 0
let g:exCS_close_when_selected = 0
let g:exCS_window_direction = 'bel'
let g:exCS_window_width = 48

" ------------------------------------------------------------------ 
" Desc: exQuickFix
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <leader>qf :ExqfSelectToggle<CR>
nnoremap <unique> <silent> <leader>qq :ExqfQuickViewToggle<CR>

let g:exQF_backto_editbuf = 0
let g:exQF_close_when_selected = 0
let g:exQF_window_direction = 'bel'

" ------------------------------------------------------------------ 
" Desc: exMacroHightlight
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <Leader>aa :ExmhSelectToggle<CR>
nnoremap <unique> <silent> <Leader>ae :ExmhHL 1 <CR>
nnoremap <unique> <silent> <Leader>ad :ExmhHL 0 <CR>

" ------------------------------------------------------------------ 
" Desc: exProject
" ------------------------------------------------------------------ 

map <unique> <silent> <A-S-p> :EXProject<CR>
" NOTE: the / can be mapped to other script ( for example exSearchComplete ), so here use nmap instead of nnoremap 
map <unique> <A-S-o> :EXProject<CR>:redraw<CR>/
map <unique> <leader>ff :EXProject<CR>:redraw<CR>/\[[^F]*\]\c.*
map <unique> <leader>fd :EXProject<CR>:redraw<CR>/\[F\]\c.*
map <unique> <leader>fc :ExpjGotoCurrentFile<CR>

let g:exPJ_backto_editbuf = 1
let g:exPJ_close_when_selected = 0
let g:exPJ_window_width_increment = 50

let g:exPJ_defualt_filter  = 'c cpp cxx c++ C cc '
let g:exPJ_defualt_filter .= 'h H hh hxx hpp inl '
let g:exPJ_defualt_filter .= 'cs '
let g:exPJ_defualt_filter .= 'uc '
let g:exPJ_defualt_filter .= 'hlsl vsh psh fx fxh cg shd glsl '
let g:exPJ_defualt_filter .= 'py pyw '
let g:exPJ_defualt_filter .= 'vim awk m '
let g:exPJ_defualt_filter .= 'dox doxygen '
let g:exPJ_defualt_filter .= 'ini cfg wiki '
let g:exPJ_defualt_filter .= 'mk err exe bat sh '

" ------------------------------------------------------------------ 
" Desc: TagList
" ------------------------------------------------------------------ 

" F4:  Switch on/off TagList
nnoremap <unique> <silent> <F4> :TlistToggle<CR>

"let Tlist_Ctags_Cmd = $VIM.'/vimfiles/ctags.exe' " location of ctags tool 
let Tlist_Show_One_File = 1 " Displaying tags for only one file~
let Tlist_Exist_OnlyWindow = 1 " if you are the last, kill yourself 
let Tlist_Use_Right_Window = 1 " split to the right side of the screen 
let Tlist_Sort_Type = "order" " sort by order or name
let Tlist_Display_Prototype = 0 " do not show prototypes and not tags in the taglist window.
let Tlist_Compart_Format = 1 " Remove extra information and blank lines from the taglist window.
let Tlist_GainFocus_On_ToggleOpen = 1 " Jump to taglist window on open.
let Tlist_Display_Tag_Scope = 1 " Show tag scope next to the tag name.
let Tlist_Close_On_Select = 0 " Close the taglist window when a file or tag is selected.
let Tlist_BackToEditBuffer = 0 " If no close on select, let the user choose back to edit buffer or not
let Tlist_Enable_Fold_Column = 0 " Don't Show the fold indicator column in the taglist window.
let Tlist_WinWidth = 40
let Tlist_Compact_Format = 1 " do not show help
" let Tlist_Ctags_Cmd = 'ctags --c++-kinds=+p --fields=+iaS --extra=+q --languages=c++'
" very slow, so I disable this
" let Tlist_Process_File_Always = 1 " To use the :TlistShowTag and the :TlistShowPrototype commands without the taglist window and the taglist menu, you should set this variable to 1.
":TlistShowPrototype [filename] [linenumber]

" ------------------------------------------------------------------ 
" Desc: MiniBufExpl
" ------------------------------------------------------------------ 

let g:miniBufExplTabWrap = 1 " make tabs show complete (no broken on two lines) 
let g:miniBufExplModSelTarget = 1 " If you use other explorers like TagList you can (As of 6.2.8) set it at 1:
let g:miniBufExplUseSingleClick = 1 " If you would like to single click on tabs rather than double clicking on them to goto the selected buffer. 
let g:miniBufExplMaxSize = 1 " <max lines: defualt 0> setting this to 0 will mean the window gets as big as needed to fit all your buffers. 
" comment out this, when we open a single file by we, we don't need minibuf opened. Minibu always open in exDev mode, in EnvironmentUpdate 
" let g:miniBufExplorerMoreThanOne = 0 " Setting this to 0 will cause the MBE window to be loaded even

"let g:miniBufExplForceSyntaxEnable = 1 " There is a VIM bug that can cause buffers to show up without their highlighting. The following setting will cause MBE to
"let g:miniBufExplMapCTabSwitchBufs = 1 
"let g:miniBufExplMapWindowNavArrows = 1

" ------------------------------------------------------------------ 
" Desc: OmniCppComplete
" ------------------------------------------------------------------ 

" set Ctrl+j in insert mode, like VS.Net
imap <unique> <C-]> <C-X><C-O>
" :inoremap <expr> <cr> pumvisible() ? "\<c-y>" : "\<c-g>u\<cr>" 

" set completeopt as don't show menu and preview
set completeopt=menuone

" use global scope search
let OmniCpp_GlobalScopeSearch = 1

" 0 = namespaces disabled
" 1 = search namespaces in the current buffer
" 2 = search namespaces in the current buffer and in included files
let OmniCpp_NamespaceSearch = 1

" 0 = auto
" 1 = always show all members
let OmniCpp_DisplayMode = 1

" 0 = don't show scope in abbreviation
" 1 = show scope in abbreviation and remove the last column
let OmniCpp_ShowScopeInAbbr = 0

" This option allows to display the prototype of a function in the abbreviation part of the popup menu.
" 0 = don't display prototype in abbreviation
" 1 = display prototype in abbreviation
let OmniCpp_ShowPrototypeInAbbr = 1

" This option allows to show/hide the access information ('+', '#', '-') in the popup menu.
" 0 = hide access
" 1 = show access
let OmniCpp_ShowAccess = 1

" This option can be use if you don't want to parse using namespace declarations in included files and want to add namespaces that are always used in your project.
let OmniCpp_DefaultNamespaces = ["std"]

" Complete Behaviour
let OmniCpp_MayCompleteDot = 0
let OmniCpp_MayCompleteArrow = 0
let OmniCpp_MayCompleteScope = 0

" When 'completeopt' does not contain "longest", Vim automatically select the first entry of the popup menu. You can change this behaviour with the OmniCpp_SelectFirstItem option.
let OmniCpp_SelectFirstItem = 0

" ------------------------------------------------------------------ 
" Desc: EnhCommentify
" ------------------------------------------------------------------ 

let g:EnhCommentifyFirstLineMode='yes'
let g:EnhCommentifyRespectIndent='yes'
let g:EnhCommentifyUseBlockIndent='yes'
let g:EnhCommentifyAlignRight = 'yes'
let g:EnhCommentifyPretty = 'yes'
let g:EnhCommentifyBindInNormal = 'no'
let g:EnhCommentifyBindInVisual = 'no'
let g:EnhCommentifyBindInInsert = 'no'
vmap <unique> <F11> <Plug>VisualComment
nmap <unique> <F11> <Plug>Comment
imap <unique> <F11> <ESC><Plug>Comment
vmap <unique> <C-F11> <Plug>VisualDeComment
nmap <unique> <C-F11> <Plug>DeComment
imap <unique> <C-F11> <ESC><Plug>DeComment

" ------------------------------------------------------------------ 
" Desc: exEnvironmentSetting
" ------------------------------------------------------------------ 

" NOTE: The exEvironmentSetting must put at the end of the plugin settings. It may update the default settings of plugin above

let g:exES_vimfile_dir = "_vimfiles"
let g:exES_project_cmd = 'EXProject'

let g:exES_ImageViewer = ''
let g:exES_WebBrowser = ''
if has("gui_running")
    if has("win32")
        let g:exES_WebBrowser = 'c:\Program Files\Mozilla Firefox\firefox.exe'
        let g:exES_ImageViewer = 'd:\exDev\IrfanView\i_view32.exe'
    elseif has("unix")
        let g:exES_WebBrowser = 'firefox'
    endif
endif
" 'c:\Documents\ and\ Settings\Johnny\Local\ Settings\Application Data\Google\Chrome\Application\chrome.exe'

function g:exES_UpdateEnvironment()
    " Open Minibuffer always, re-adjust project position
    let g:miniBufExplorerMoreThanOne = 0 
    if exists(':MiniBufExplorer')
        silent exe "MiniBufExplorer"
    endif

    " set parent working directory
    if exists( 'g:exES_CWD' )
        silent exec 'cd ' . g:exES_CWD
    endif

    " set tag file path
    if exists( 'g:exES_Tag' )
        "let &tags = &tags . ',' . g:exES_Tag
        let &tags = escape(g:exES_Tag, " ")
    endif

    " open exProject window
    if exists( 'g:exES_Project' )
        silent exec g:exES_project_cmd.' '.g:exES_Project
    endif

    " init macro list
    if exists( 'g:exES_Macro' )
        silent call g:exMH_InitMacroList(g:exES_Macro)
    endif

    " connect cscope file
    if exists( 'g:exES_Cscope' )
        silent call g:exCS_ConnectCscopeFile()
    endif

    " set vimentry references
    if exists ('g:exES_vimentryRefs')
        for vimentry in g:exES_vimentryRefs
            let entry_dir = fnamemodify( vimentry, ':p:h')
            let fullpath_tagfile = g:ex_GetVimFile ( entry_dir, 'tag')
            if has ('win32')
                let fullpath_tagfile = g:ex_Pathfmt( fullpath_tagfile, 'windows' )
            elseif has ('unix')
                let fullpath_tagfile = g:ex_Pathfmt( fullpath_tagfile, 'unix' )
            endif
            if findfile ( fullpath_tagfile ) != ''
                let &tags .= ',' . fullpath_tagfile
            endif
        endfor
    endif

	" set visual_studio plugin variables
	if exists( 'g:exES_vsTaskList' )
		let g:visual_studio_task_list = g:exES_vsTaskList
	endif
	if exists( 'g:exES_vsOutput' )
		let g:visual_studio_output = g:exES_vsOutput
	endif
	if exists( 'g:exES_vsFindResult1' )
		let g:visual_studio_find_results_1 = g:exES_vsFindResult1
	endif
	if exists( 'g:exES_vsFindResult2' )
		let g:visual_studio_find_results_2 = g:exES_vsFindResult2
	endif

    " set vimwiki
	if exists( 'g:exES_wikiHome' )
        let g:vimwiki_home = g:exES_wikiHome 
    endif
	if exists( 'g:exES_wikiHomeHtml' )
        let g:vimwiki_home_html = g:exES_wikiHomeHtml 
    endif
endfunction

"/////////////////////////////////////////////////////////////////////////////
" Other settings
"/////////////////////////////////////////////////////////////////////////////

